# -*- coding: utf-8 -*-
"""Model11/4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OhNbnB88qFmNny27IR4Rc-tz8r1ZujkP
"""

!pip install -q pyomo
!apt-get install -y -qq glpk-utils

from pyomo.environ import *
from pyomo.opt import SolverFactory
import numpy as np

I = 5
Np = 3
np.random.seed(2500)
f = np.random.randint(20, size = (I,I))*10
for i in range(I):
    f[i,i]=0
print(f)

# drunken driver probability on arc ij
p = (np.random.rand(I,I)).round(1)
for j in range(I):
    p[j,j]=0
print(p)


N = np.zeros((I,I))
for i in range(I):
    for j in range(I):
        N[i,j] = f[i,j]*p[i,j]
print(N) 

ra = 0.7
rt = 0.3

c = np.random.randint(10,size=(I,I))
for i in range(I):
    c[i,i] = 0
c_penalty = 100
print(c)

# create a model
model = ConcreteModel()

# declare decision variables
model.z = Var(range(I), range(I), domain=NonNegativeReals)
model.x = Var(range(I), range(I), domain=Binary)
model.D = Var(range(I), range(I), domain=NonNegativeReals)
model.alpha = Var(range(I), range(I))
model.beta = Var(range(I), range(I))
model.y = Var(range(I), range(I), range(I), domain=NonNegativeReals)
model.q = Var(range(I), range(I), domain=Binary)
model.qq = Var(range(I), range(I), range(I), domain=Binary)

# declare objective
model.obj = Objective(expr = sum(model.z[i,j] for i in range(I) for j in range(I)) , sense=maximize)

# declare constraints
model.bound = ConstraintList()
for i in range(I):
  for j in range(I):
    # model.bound.add(model.z[i,j] == model.x[i,j] * model.D[i,j]) #3b
    model.bound.add(model.z[i,j] >= 0) #3c
    model.bound.add(model.z[i,j] >= model.D[i,j] + model.x[i,j] * 1000 - 1000) #3d
    model.bound.add(model.z[i,j] <= model.D[i,j]) #3e
    model.bound.add(model.z[i,j] <= model.x[i,j] * 1000) #3f  
    model.bound.add(model.alpha[i,j] <= c[i,j] + c_penalty*model.x[i,j]) #3i
    model.bound.add(model.D[i,j] <= 1000 * model.q[i,j]) #3l1
    model.bound.add(-model.alpha[i,j] + c[i,j] + c_penalty*model.x[i,j] <= 1000*(1-model.q[i,j])) #3l2
    model.bound.add(sum(model.y[i,j,k] for k in range(I)) - N[i,j]*model.x[i,j]*ra == 0)
    model.bound.add(model.D[i,j]-N[i,j]+sum(model.y[i,j,d] for d in range(I))-sum(model.y[i,k,j] for k in range(I)) == 0) #3k

for i in range(I):
  for j in range(I):
    for k in range(I):
      if k != i and k!= j:
        model.bound.add(model.beta[i,j] + model.alpha[i,j] - model.alpha[i,k] <= 0) # 3j
        model.bound.add(model.y[i,j,k] <= 1000*model.qq[i,j,k]) #3m1
        model.bound.add(-model.beta[i,j] - model.alpha[i,j] + model.alpha[i,k] <= 1000 * (1-model.qq[i,j,k])) #3m2
       

model.bound.add(sum(model.x[i,j] for i in range(I) for j in range(I)) <= Np) #3g   

#for i in range(I):
  #for j in range(I):
    #for k in range(I):
      #for d in range(I):
        #if d != i and d!= j and k!= i and k!= j:
          #model.bound.add(model.D[i,j]-N[i,j]+sum(model.y[i,j,d] for d in range(I))-sum(model.y[i,k,j] for k in range(N)) == 0) #3k

SolverFactory("glpk").solve(model)

# opt = SolverFactory('glpk')
# opt.solve(model)

